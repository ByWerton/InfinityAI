import React, { useState, useEffect, useRef } from 'react';
import { Send, Code, Image as ImageIcon, Sparkles, X, Play, Copy, Zap, Cpu, ArrowLeft, Camera, Download, Film, Loader2, Video } from 'lucide-react';

// --- Sabitler ve Yardımcı Fonksiyonlar ---
const GEMINI_API_KEY = ''; 
const logoUrl = 'https://raw.githubusercontent.com/ByWerton/InfinityAI/refs/heads/main/1764172777146.png';

const extractCode = (content) => {
  const codeBlockRegex = /```(html|jsx|javascript|js|css|typescript|ts)\n([\s\S]*?)```/g;
  let match;
  let webCode = null;
  while ((match = codeBlockRegex.exec(content)) !== null) {
    const language = match[1];
    const code = match[2].trim();
    if (language === 'html' || language === 'jsx') return code; 
    if (['javascript', 'js', 'css', 'ts', 'typescript'].includes(language)) {
        webCode = `<html><head><script src="https://cdn.tailwindcss.com"></script><style>html, body { margin: 0; padding: 0; height: 100%; }</style></head><body><script>${code}</script></body></html>`;
    }
  }
  return webCode;
};

// --- Video Planı JSON Şeması (Gemini'nin Anlaması İçin) ---
// Seslendirme metinleri çıkarıldı.
const videoPlanSchema = {
    type: "OBJECT",
    properties: {
        title: { type: "STRING", description: "Videonun başlığı." },
        duration_seconds: { type: "NUMBER", description: "Videonun saniye cinsinden toplam süresi (minimum 10 saniye)." },
        style: { type: "STRING", description: "Videonun görsel stili ve tonu (örneğin, sinematik, belgesel, canlı renkler). Bu, Imagen istemi olarak kullanılacak." },
        scenes: { 
            type: "ARRAY", 
            description: "Videonun sahne sahne dökümü.",
            items: {
                type: "OBJECT",
                properties: {
                    scene_number: { type: "NUMBER" },
                    duration: { type: "NUMBER", description: "Sahnenin saniye cinsinden süresi." },
                    visual_description: { type: "STRING", description: "Imagen 4.0 için kullanılacak görsel açıklaması." },
                },
                propertyOrdering: ["scene_number", "duration", "visual_description"]
            }
        }
    },
    propertyOrdering: ["title", "duration_seconds", "style", "scenes"]
};

// --- API Çağrısı (Vision Desteğiyle) ---
const callGemini = async (prompt, modelOverride, imagePayload = null, structuredSchema = null) => {
    let delay = 1000; 
    const maxRetries = 5;
    const contents = [{ 
      parts: [
        { text: prompt },
        ...(imagePayload ? [{ 
          inlineData: { mimeType: imagePayload.mimeType, data: imagePayload.data }
        }] : [])
      ]
    }];
    
    const payload = { 
        contents: contents,
        ...(structuredSchema && { 
            generationConfig: { responseMimeType: "application/json", responseSchema: structuredSchema }
        })
    };
    const apiBody = JSON.stringify(payload);
    
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelOverride}:generateContent?key=${GEMINI_API_KEY}`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: apiBody
        });
        const data = await response.json();
        
        if (!response.ok || data.error || data.candidates?.[0]?.finishReason === 'RECITATION') {
             if (attempt < maxRetries - 1) {
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2; 
                continue; 
            } else {
                 throw new Error(data.error?.message || `API Hatası: ${response.status}. Lütfen Gemini'nin yanıtını kontrol edin.`);
            }
        }

        if (structuredSchema) {
            const jsonText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) throw new Error("Yapılandırılmış JSON yanıtı boş.");
            return JSON.parse(jsonText);
        }
        return data.candidates[0].content.parts[0].text;
      } catch (error) {
         if (attempt < maxRetries - 1) {
           await new Promise(resolve => setTimeout(resolve, delay));
           delay *= 2;
           continue; 
        }
        throw error;
      }
    }
    throw new Error("API çağrısı tüm denemelerde başarısız oldu.");
  };

// --- Node.js Backend Simülasyonu ---
// Artık sadece görsel üretimi ve FFmpeg ile birleştirmeyi simüle eder.
const mockBackendVideoGeneration = async (videoPlan) => {
    // Gerçekte bu aşamada:
    // 1. Imagen (Görsel) API çağrıları yapılır.
    // 2. FFmpeg tüm görselleri senkronize eder (ses olmadan).
    // 3. Video Buluta yüklenir (CDN).
    
    return new Promise((resolve) => {
        // Simülasyon süresi: 3-6 saniye
        const duration = Math.random() * 3000 + 3000;
        
        setTimeout(() => {
            // Başarılı bir video oluşturma sonucu
            const mockVideoUrl = "https://placehold.co/600x400/363636/E0E0E0/webp?text=GÖRSEL+VİDEO+OLUŞTURULDU"; 
            resolve({ 
                success: true, 
                url: mockVideoUrl,
                backendLog: "Node.js Backend Başarılı: Görseller (Imagen) oluşturuldu ve FFmpeg ile SESSİZ video olarak birleştirildi. Video URL'si döndürüldü."
            });
        }, duration);
    });
};

// --- Ana Uygulama Bileşeni ---

export default function InfinityAIStudio() {
  const [messages, setMessages] = useState([
    { id: 1, role: 'system', content: 'Merhaba! Ben **InfinityAI**. Video modu şu anda **SADECE GÖRSEL** (Imagen + FFmpeg Simülasyonu) olarak çalışmaktadır. Lütfen bir video isteği girin.', type: 'text' }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [currentCode, setCurrentCode] = useState('');
  const [selectedMode, setSelectedMode] = useState('video'); // Default Video Modu
  const [currentStep, setCurrentStep] = useState(''); 
  const [copyMessage, setCopyMessage] = useState(''); 
  const [showModeSelector, setShowModeSelector] = useState(false);
  const [imageUrl, setImageUrl] = useState(null); 
  const [imageData, setImageData] = useState(null); 
  const [imageMimeType, setImageMimeType] = useState(null); // Fix: Added useState for imageMimeType

  const chatContainerRef = useRef(null);
  const fileInputRef = useRef(null);

  const modes = ['canvas', 'tek_sefer', 'video'];
  
  const handleModeSelect = (mode) => {
    setSelectedMode(mode);
    setShowModeSelector(false); 
    setShowPreview(false);
    clearImage();
  };
  
  const getModeLabel = (mode) => {
      switch (mode) {
          case 'canvas': return 'Canvas (Kod)';
          case 'tek_sefer': return 'Tek Sefer (Metin)';
          case 'video': return 'SADECE GÖRSEL Video Üretimi (Gemini + Node.js Simülasyonu)';
          default: return 'Bilinmiyor';
      }
  };

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [messages, isLoading]);
  
  const clearImage = () => {
    setImageUrl(null);
    setImageData(null);
    setImageMimeType(null);
    if (fileInputRef.current) fileInputRef.current.value = null;
  };
  
  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64String = reader.result.split(',')[1];
        setImageUrl(reader.result);
        setImageData(base64String);
        setImageMimeType(file.type);
      };
      reader.readAsDataURL(file);
    }
  };

  const copyCodeToClipboard = (rawCode, lang) => {
    const textarea = document.createElement('textarea');
    textarea.value = rawCode;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    try {
        document.execCommand('copy');
        const languageName = lang ? lang.toUpperCase() : 'KOD';
        setCopyMessage(`${languageName} kodu başarıyla panoya kopyalandı!`);
    } catch (err) {
        setCopyMessage('Kopyalama başarısız oldu.');
    }
    document.body.removeChild(textarea);
    setTimeout(() => setCopyMessage(''), 3000);
  };


  // --- Mesaj Gönderme Mantığı ---

  const handleSend = async () => {
    if (!input.trim() && !imageData) return;

    const userMsg = { id: Date.now(), role: 'user', content: input, type: 'text' };
    setMessages(prev => [...prev, userMsg]);
    setInput('');
    setIsLoading(true);
    setCurrentStep('');
    setShowModeSelector(false);

    const imagePayload = imageData ? { data: imageData, mimeType: imageMimeType } : null;
    clearImage(); 

    try {
      if (selectedMode === 'video') {
        
        // 1. ADIM: PLANLAMA (Gemini: İsteği anlar ve yapılandırılmış planı oluşturur)
        setCurrentStep('Adım 1/3: Gemini ile SADECE GÖRSEL video içeriği planlanıyor (Sahne Dökümü, Süre)...');
        // Use userMsg.content directly for the prompt as the user intended
        const userPrompt = `Aşağıdaki video isteği için Imagen 4.0'a uygun, saniye cinsinden süreler içeren detaylı bir JSON sahne dökümü oluştur. İstek: "${userMsg.content}"`;
        const videoPlan = await callGemini(userPrompt, 'gemini-2.5-flash-preview-09-2025', imagePayload, videoPlanSchema);
        
        if (!videoPlan || !videoPlan.scenes || videoPlan.scenes.length === 0) {
            throw new Error("Gemini geçerli bir video planı oluşturamadı.");
        }
        
        // 2. ADIM: ORKESTRASYON GÖNDERİMİ (Frontend -> Hayali Node.js Backend'e)
        setCurrentStep('Adım 2/3: Yapılandırılmış plan, görsel oluşturma ve birleştirme için Node.js Video Backend\'ine gönderiliyor...');
        
        // Gerçekte burada bir 'fetch' çağrısı ile plan Node.js sunucusuna JSON olarak gönderilir.
        const backendResponse = await mockBackendVideoGeneration(videoPlan);
        
        if (!backendResponse.success) {
            throw new Error(`Video Üretimi Backend Hatası: ${backendResponse.backendLog}`);
        }

        // 3. ADIM: BAŞARILI SONUÇ (Frontend: Gelen Video URL'sini Alır ve Gösterir)
        setCurrentStep('Adım 3/3: SESSİZ video başarıyla birleştirildi ve akış için URL alınıyor...');

        const botMsgContent = `
            Video Üretim Sonucu (SADECE GÖRSEL):

            **[ADIM 1: PLANLAMA - Gemini Tarafından Oluşturuldu]**
            Başlık: **${videoPlan.title}** | Toplam Süre: **${videoPlan.duration_seconds} saniye** | Stil: **${videoPlan.style}**
            
            **Sahne Dökümü:**
            ${videoPlan.scenes.map(s => (
                `* Sahne ${s.scene_number} (${s.duration}s): Görsel İstem: "${s.visual_description}"`
            )).join('\n')}

            ---
            
            **[ADIM 2 & 3: ÜRETİM - InfinityAI Node.js Backend'i Simülasyonu]**
            Backend Logu: \`${backendResponse.backendLog}\`
            
            Video URL'si başarıyla alındı ve aşağıda önizleniyor. Kodu açarak oynatıcıyı görebilirsiniz.
            
            \`\`\`html:Oluşturulmuş Sessiz Video Oynatıcı:generated_silent_video.html
            <!DOCTYPE html>
            <html lang="tr">
            <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>${videoPlan.title} (Sessiz)</title>
              <script src="https://cdn.tailwindcss.com"></script>
            </head>
            <body class="bg-gray-950 flex flex-col items-center justify-center min-h-screen p-4 font-sans text-white">
              <div class="w-full max-w-2xl bg-gray-900 rounded-xl shadow-2xl border border-red-700 overflow-hidden">
                <h1 class="text-2xl font-bold p-4 bg-red-700 text-center">${videoPlan.title} (Sessiz Video)</h1>
                
                <div class="p-6">
                  <!-- Gerçek video oynatıcı (URL'yi kullanır) -->
                  <video controls class="w-full aspect-video rounded-lg shadow-xl border border-gray-700" poster="https://placehold.co/600x400/363636/E0E0E0?text=SESSİZ+GÖRSEL+VİDEO+YÜKLENİYOR" onerror="this.src='https://placehold.co/600x400/AA0000/FFFFFF?text=HATA%20YÜKLENEMEDİ'">
                    <!-- DİKKAT: Bu URL sadece simülasyon amaçlı bir görseldir. Gerçekte, Node.js Backend'inden gelen MP4 URL'si burada olurdu. -->
                    <source src="${backendResponse.url}" type="video/mp4">
                    Tarayıcınız video oynatmayı desteklemiyor.
                  </video>
                  
                  <a href="${backendResponse.url}" download="${videoPlan.title.replace(/\s/g, '_')}_sessiz.mp4" class="mt-4 block text-center bg-red-600 hover:bg-red-500 text-white font-bold py-2 rounded-lg transition-colors">
                    <div class="flex items-center justify-center gap-2">
                        <Download size={18} /> Videoyu İndir (Simülasyon Dosyası)
                    </div>
                  </a>
                  
                  <div class="mt-6 p-4 bg-gray-950 rounded-lg text-sm border border-gray-700">
                    <h2 class="text-red-400 font-bold mb-2">Video Özeti</h2>
                    <p class="text-gray-400">Bu video, Gemini'nin planına göre oluşturulmuştur. Görseller Imagen 4.0 kullanılarak Node.js sunucusunda SESSİZ olarak işlenmiştir (Simülasyon).</p>
                  </div>
                </div>
              </div>
            </body>
            </html>
            \`\`\`
        `;
        
        const botMsg = { id: Date.now() + 1, role: 'ai', content: botMsgContent, type: 'text', model: `Video Üretim (Sadece Görsel)` };
        setMessages(prev => [...prev, botMsg]);

        setCurrentCode(extractCode(botMsgContent));
        setShowPreview(true);


      } else { // 'canvas' veya 'tek_sefer' modları (Basit metin veya kod yanıtı)
        // ... (Diğer modların mantığı basitleştirilmiştir) ...
        setCurrentStep('InfinityAI yanıt oluşturuyor...');
        const responseContent = await callGemini(userMsg.content, 'gemini-2.5-flash-preview-09-2025', imagePayload);
        
        const extractedHTML = extractCode(responseContent);
        if (extractedHTML) { setCurrentCode(extractedHTML); setShowPreview(true); } else { setCurrentCode(''); setShowPreview(false); }
        
        const botMsg = { id: Date.now() + 1, role: 'ai', content: responseContent, type: 'text', model: `Tek Sefer Yanıt` };
        setMessages(prev => [...prev, botMsg]);
      }

    } catch (error) {
      setMessages(prev => [...prev, {
        id: Date.now() + 1,
        role: 'system',
        content: `Ciddi Hata Oluştu: ${error.message}. Hata Noktası: ${currentStep}`,
        type: 'error'
      }]);
    } finally {
      setIsLoading(false);
      setCurrentStep(''); 
    }
  };

  return (
    <div className="flex flex-col h-screen bg-gray-950 text-gray-100 font-sans overflow-hidden">
      
      {/* Header (Aesthetics remain the same) */}
      <div className="flex justify-between items-center p-4 bg-gray-900 border-b border-red-700">
        <div className="flex items-center gap-3 text-red-500">
          <img src={logoUrl} alt="InfinityAI Logo" className="w-8 h-8 rounded-full shadow-lg border border-red-500" />
          <h1 className="text-xl font-bold tracking-wider">InfinityAI</h1>
        </div>
      </div>
      
      {/* Copy Message Popup */}
      {copyMessage && (
          <div className={`fixed top-4 right-4 z-50 px-4 py-2 rounded-lg shadow-xl text-white ${
              copyMessage.includes('başarıyla') ? 'bg-green-600' : 'bg-red-600'
          } transition-opacity duration-500`}>
              {copyMessage}
          </div>
      )}

      {/* Main Chat Area / Full Preview */}
      <div className="flex-1 flex flex-row relative overflow-hidden">
        
        {/* Chat Log */}
        <div 
            className={`flex-1 flex flex-col overflow-y-auto p-6 space-y-6 transition-all duration-300 ${showPreview ? 'w-1/2' : 'w-full'}`} 
            ref={chatContainerRef}
        >
          {messages.map((msg) => (
            <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
              <div className={`max-w-[80%] rounded-2xl p-4 shadow-xl ${
                msg.role === 'user' 
                  ? 'bg-red-700 text-white rounded-br-none' 
                  : msg.type === 'error' 
                    ? 'bg-black border border-red-500 text-red-300'
                    : 'bg-gray-900 border border-gray-800 text-gray-100 rounded-bl-none'
              }`}>
                {msg.role === 'ai' && (
                  <div className="flex items-center gap-2 mb-2 text-xs font-mono text-red-400 opacity-75">
                    <img src={logoUrl} alt="AI Logo" className="w-4 h-4 rounded-full" />
                    <span>{msg.model}</span>
                  </div>
                )}
                
                <div className="whitespace-pre-wrap leading-relaxed">
                    {msg.content.split('```').map((part, index) => {
                      if (index % 2 === 1) {
                        const codeContent = part.trim();
                        const firstLineEnd = codeContent.indexOf('\n');
                        const header = firstLineEnd !== -1 ? codeContent.substring(0, firstLineEnd) : '';
                        const actualCode = firstLineEnd !== -1 ? codeContent.substring(firstLineEnd + 1) : codeContent;
                        
                        let displayLang = 'Kod';
                        const langMatch = header.match(/^(\w+):/);
                        if (langMatch) displayLang = langMatch[1].toUpperCase();

                        return (
                          <div key={index} className="bg-gray-800 p-3 rounded my-2 text-xs font-mono overflow-x-auto border border-red-800">
                            <div className="text-right text-red-400 mb-1 border-b border-gray-700 pb-1 pr-1 font-bold">{displayLang} ÇIKTISI</div>
                            <pre className="whitespace-pre-wrap text-white">{actualCode}</pre>
                          </div>
                        );
                      }
                      return <span key={index}>{part}</span>;
                    })}
                </div>

                {msg.role === 'ai' && extractCode(msg.content) && (selectedMode === 'video' || selectedMode === 'canvas') && (
                  <button 
                    onClick={() => {
                      setCurrentCode(extractCode(msg.content));
                      setShowPreview(true);
                    }}
                    className="mt-3 flex items-center gap-2 text-xs bg-red-600 hover:bg-red-500 px-3 py-1.5 rounded transition-colors shadow-md hover:shadow-lg text-white font-bold"
                  >
                    <Play size={14} />
                    Canvas Önizleme (Aç)
                  </button>
                )}
              </div>
            </div>
          ))}
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-gray-900 p-4 rounded-2xl rounded-bl-none flex flex-col items-start gap-1 shadow-md border border-red-700">
                <div className="flex items-center gap-3">
                  <img src={logoUrl} alt="AI Logo" className="w-5 h-5 animate-spin" />
                  <span className="text-sm font-bold text-gray-200">InfinityAI</span>
                </div>
                {currentStep && <span className="text-xs text-red-400 mt-1 flex items-center gap-1"><Loader2 size={12} className="animate-spin"/>{currentStep}</span>}
              </div>
            </div>
          )}
          <div className="h-4"></div> 
        </div>

        {/* Code Preview Panel */}
        {showPreview && (
          <div className={`bg-white border-l border-red-700 flex flex-col shadow-2xl animate-in slide-in-from-right duration-300 ${showPreview ? 'w-full md:w-1/2' : 'w-full'}`}>
            <div className="bg-gray-100 p-3 flex justify-start items-center border-b border-gray-300">
                <button 
                    onClick={() => setShowPreview(false)}
                    className="flex items-center gap-2 p-2 text-white hover:bg-red-700 bg-red-600 rounded-lg transition-colors font-bold shadow-md"
                >
                    <ArrowLeft size={20} />
                    <span>Sohbete Geri Dön</span>
                </button>
            </div>
            <div className="flex-1 bg-white relative">
               <iframe 
                 srcDoc={currentCode} 
                 title="Preview"
                 className="w-full h-full border-none"
                 sandbox="allow-scripts allow-forms allow-modals allow-same-origin"
               />
            </div>
          </div>
        )}
      </div>

      {/* Input Area and Mode Selector */}
      <div className="p-4 bg-gray-900 border-t border-red-700">
        
        {/* Active Image Preview (Vision) */}
        {imageUrl && (
            <div className="max-w-4xl mx-auto mb-4 p-3 bg-gray-800 border border-red-700 rounded-xl flex items-center justify-between">
                <div className="flex items-center gap-3">
                    <ImageIcon size={20} className="text-red-500 flex-shrink-0" />
                    <span className="text-sm text-gray-300 font-medium">Görsel Analiz İçin Hazır:</span>
                    <img src={imageUrl} alt="Preview" className="h-10 w-10 object-cover rounded border border-gray-600" />
                </div>
                <button onClick={clearImage} className="flex items-center gap-1 text-xs text-red-400 hover:text-red-300 transition-colors">
                    <X size={16} />
                    Kaldır
                </button>
            </div>
        )}
        
        <div className="flex gap-3 max-w-4xl mx-auto mb-4 relative">
            
            {/* Mode Selector Button */}
            <button 
                onClick={() => setShowModeSelector(!showModeSelector)}
                className="flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-xl text-sm font-bold transition-colors bg-red-700 text-white shadow-md border border-red-500 hover:bg-red-600"
            >
                <Zap size={18} /> 
                Mod Seç: {getModeLabel(selectedMode)}
            </button>
            
            {/* Mode Selector Dropdown/Modal */}
            {showModeSelector && (
                <div className="absolute bottom-full mb-2 w-full max-w-full bg-gray-800 border border-red-700 rounded-xl shadow-2xl z-20 overflow-hidden animate-in fade-in slide-in-from-bottom-2 duration-200">
                    {modes.map(mode => (
                        <button
                            key={mode}
                            onClick={() => handleModeSelect(mode)}
                            className={`w-full text-left p-3 flex items-center justify-between text-sm transition-colors ${
                                selectedMode === mode ? 'bg-red-700 text-white' : 'text-gray-200 hover:bg-gray-700'
                            }`}
                        >
                            {getModeLabel(mode)}
                            {selectedMode === mode && <Sparkles size={16} className="text-yellow-400" />}
                            {mode === 'video' && <Video size={16} className="text-red-300" />}
                            {mode === 'canvas' && <Code size={16} className="text-red-300" />}
                        </button>
                    ))}
                </div>
            )}
            
            {/* Resim/Kamera Yükleme Butonları */}
            <input type="file" ref={fileInputRef} accept="image/*" onChange={handleImageUpload} className="hidden" />
            <button 
                onClick={() => fileInputRef.current.click()}
                title="Resim Yükle (Vision Analizi)"
                className="p-3 rounded-xl bg-gray-800 text-gray-300 hover:bg-gray-700 transition-colors"
            >
                <ImageIcon size={20} />
            </button>
        </div>
        
        <div className="flex gap-3 max-w-4xl mx-auto">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && handleSend()}
            placeholder={`Video isteğinizi buraya yazın: "Mars'ta geçen 30 saniyelik bir bilim kurgu tanıtımı yap."`}
            className="flex-1 bg-gray-950 border border-gray-700 text-white rounded-xl px-4 py-3 focus:outline-none focus:border-red-500 transition-all placeholder:text-gray-500"
          />
          <button 
            onClick={handleSend}
            disabled={isLoading || (!input.trim() && !imageData)}
            className="bg-red-600 hover:bg-red-500 text-white p-3 rounded-xl transition-all disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-red-500/30"
          >
            <Send size={24} />
          </button>
        </div>
      </div>
    </div>
  );
}

